"use client";

import React, { FC, useState } from "react";
import { motion } from "framer-motion";
import { CodeBlock } from "@/components/ui/CodeBlock";

interface Template {
  title: string;
  description: string;
  prompt: string;
  example: string;
  category: string;
}

const CommonTemplates: FC = () => {
  const [activeCategory, setActiveCategory] = useState<string>("Component");
  const [activeTemplate, setActiveTemplate] = useState<number>(0);

  const templates: Template[] = [
    // Component Templates
    {
      title: "Cursor AI Component",
      description:
        "Create an intelligent React component using Cursor AI's advanced features",
      category: "Component",
      prompt: `@cursor
Create a React component using Cursor AI features:
- Name: [ComponentName]
- Props: [list props]
- Features:
  - TypeScript types with strict checks
  - Error boundaries with Cursor AI error reporting
  - AI-optimized loading states
  - ARIA-compliant accessibility
  - Performance optimizations using Cursor AI analysis
  - Integration with Cursor AI's type inference
- Include JSDoc documentation
- Add unit tests with Cursor AI test generation

Note: Use Cmd/Ctrl + K to refine the component interactively`,
      example: `// Generated by Cursor AI
// Use Cmd/Ctrl + K to get AI assistance
// Use Cmd/Ctrl + L for inline code suggestions
// Use Cmd/Ctrl + Shift + L for multi-line edits

interface Props {
  data: DataType;
  onUpdate: (data: DataType) => Promise<void>;
  isLoading?: boolean;
  aiAnalysis?: boolean; // Enable Cursor AI performance analysis
}

/**
 * Smart component with Cursor AI-powered features
 * @uses Cursor AI error handling
 * @uses Cursor AI performance optimization
 * @uses Cursor AI accessibility checks
 */
export const CursorComponent: FC<Props> = ({
  data,
  onUpdate,
  isLoading = false,
  aiAnalysis = true,
}) => {
  const [error, setError] = useState<Error | null>(null);

  // Memoize expensive computations
  const processedData = useMemo(() => 
    processData(data),
    [data]
  );

  // Optimized event handler
  const handleUpdate = useCallback(async () => {
    try {
      await onUpdate(processedData);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Update failed'));
    }
  }, [processedData, onUpdate]);

  if (error) {
    return <ErrorBoundary error={error} />;
  }

  return (
    <div role="region" aria-busy={isLoading}>
      <h2>{processedData.title}</h2>
      <button
        onClick={handleUpdate}
        disabled={isLoading}
        aria-disabled={isLoading}
      >
        {isLoading ? 'Processing...' : 'Update'}
      </button>
    </div>
  );
};`,
    },
    {
      title: "Cursor AI Form",
      description:
        "Generate a smart form with Cursor AI's validation and optimization features",
      category: "Component",
      prompt: `@cursor
Create a form component using Cursor AI features:
- Advanced validation with AI-powered schema generation
- Real-time error checking with AI suggestions
- TypeScript types with Cursor AI type inference
- AI-optimized loading states
- ARIA-compliant accessibility
- Error boundaries with AI error analysis
- Performance optimization using Cursor AI profiling

Pro tip: Use Cmd/Ctrl + K during development for:
- Schema validation improvements
- Error message refinements
- Accessibility enhancements
- Performance optimizations`,
      example: `// Generated by Cursor AI
// Use Cmd/Ctrl + K for AI assistance with schema validation
// Use Cmd/Ctrl + L for inline suggestions
import { z } from 'zod';

const formSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Include uppercase letter')
    .regex(/[0-9]/, 'Include number'),
});

type FormData = z.infer<typeof formSchema>;

export const SmartForm: FC = () => {
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: ''
  });
  const [errors, setErrors] = useState<Partial<FormData>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Debounced validation
  const validateField = useCallback(
    debounce(async (field: keyof FormData, value: string) => {
      try {
        await formSchema.pick({ [field]: true }).parseAsync({ [field]: value });
        setErrors(prev => ({ ...prev, [field]: undefined }));
      } catch (error) {
        if (error instanceof z.ZodError) {
          setErrors(prev => ({
            ...prev,
            [field]: error.errors[0].message
          }));
        }
      }
    }, 300),
    []
  );

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    try {
      const validData = await formSchema.parseAsync(formData);
      await submitForm(validData);
    } catch (error) {
      if (error instanceof z.ZodError) {
        setErrors(error.flatten().fieldErrors);
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} noValidate>
      <div role="group" aria-labelledby="form-title">
        <h2 id="form-title">Login</h2>
        
        <input
          type="email"
          value={formData.email}
          onChange={e => {
            setFormData(prev => ({
              ...prev,
              email: e.target.value
            }));
            validateField('email', e.target.value);
          }}
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? 'email-error' : undefined}
        />
        {errors.email && (
          <span id="email-error" role="alert">
            {errors.email}
          </span>
        )}

        {/* Similar pattern for password field */}
      </div>
    </form>
  );
};`,
    },
    // Hook Templates
    {
      title: "Cursor AI Hook",
      description: "Create a custom hook with Cursor AI's advanced features",
      category: "Hook",
      prompt: `@cursor
Create a custom hook using Cursor AI features:
- Name: use[Name]
- Features:
  - AI-powered state management
  - Performance optimization with Cursor AI analysis
  - TypeScript types with AI type inference
  - Error handling with AI error analysis
  - Automatic cleanup with AI memory leak detection
  - AI-generated documentation
  - AI-generated tests

Pro tip: Use Cmd/Ctrl + K to:
- Analyze hook performance
- Generate test cases
- Improve error handling
- Optimize cleanup logic`,
      example: `// Generated by Cursor AI
// Use Cmd/Ctrl + K for AI assistance
// Use Cmd/Ctrl + L for inline suggestions

/**
 * Custom hook powered by Cursor AI
 * @uses Cursor AI performance optimization
 * @uses Cursor AI error analysis
 * @uses Cursor AI memory leak detection
 */
interface Options<T> {
  initialData?: T;
  validateData?: (data: T) => boolean;
  onError?: (error: Error) => void;
}

/**
 * Smart hook for data management with validation and error handling
 */
export const useSmartData = <T>(
  fetchFn: () => Promise<T>,
  options: Options<T> = {}
) => {
  const {
    initialData,
    validateData = () => true,
    onError
  } = options;

  const [data, setData] = useState<T | undefined>(initialData);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(!initialData);

  // Memoize fetch function
  const memoizedFetch = useCallback(async () => {
    setIsLoading(true);
    try {
      const result = await fetchFn();
      if (validateData(result)) {
        setData(result);
        setError(null);
      } else {
        throw new Error('Invalid data received');
      }
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Fetch failed');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [fetchFn, validateData, onError]);

  // Auto-cleanup effect
  useEffect(() => {
    let mounted = true;

    const fetch = async () => {
      if (!data) {
        await memoizedFetch();
      }
    };

    if (mounted) {
      fetch();
    }

    return () => {
      mounted = false;
    };
  }, [data, memoizedFetch]);

  return {
    data,
    error,
    isLoading,
    refetch: memoizedFetch
  };
};`,
    },
    // API Templates
    {
      title: "Cursor AI API Route",
      description:
        "Create a secure API route with Cursor AI's intelligent features",
      category: "API",
      prompt: `@cursor
Create an API route using Cursor AI features:
- Method handling with AI-powered validation
- Input/Output schema generation with AI
- Type safety with Cursor AI type inference
- AI-powered error handling and logging
- Security measures with AI vulnerability analysis
- Rate limiting with AI traffic analysis
- Response optimization with Cursor AI

Pro tip: Use Cmd/Ctrl + K to:
- Generate API documentation
- Add security measures
- Optimize response handling
- Add test cases`,
      example: `// Generated by Cursor AI
// Use Cmd/Ctrl + K for AI assistance
// Use Cmd/Ctrl + L for inline suggestions

import { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import rateLimit from 'express-rate-limit';
import { cors } from '@/lib/middleware';

/**
 * API Route with Cursor AI security and optimization
 * @uses Cursor AI input validation
 * @uses Cursor AI security analysis
 * @uses Cursor AI performance optimization
 */

// AI-generated input validation schema
const RequestSchema = z.object({
  userId: z.string().uuid(),
  action: z.enum(['create', 'update', 'delete']),
  data: z.record(z.unknown())
});

type RequestData = z.infer<typeof RequestSchema>;
type ResponseData = {
  success: boolean;
  data?: unknown;
  error?: string;
};

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100
});

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  try {
    // Apply middleware
    await cors(req, res);
    await limiter(req, res);

    // Method validation
    if (req.method !== 'POST') {
      return res.status(405).json({
        success: false,
        error: 'Method not allowed'
      });
    }

    // Input validation
    const validData = await RequestSchema.parseAsync(req.body);

    // Process request
    const result = await processRequest(validData);

    // Return success response
    return res.status(200).json({
      success: true,
      data: result
    });
  } catch (error) {
    // Error handling
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        error: 'Invalid request data'
      });
    }

    // Log error safely
    console.error('API Error:', {
      message: error instanceof Error ? error.message : 'Unknown error',
      path: req.url
    });

    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
}`,
    },
    // Utility Templates
    {
      title: "Cursor AI Utility",
      description:
        "Create an intelligent utility function with Cursor AI's advanced features",
      category: "Utility",
      prompt: `@cursor
Create a utility function using Cursor AI features:
- Name: [name]
- Features:
  - Advanced type safety with AI type inference
  - Intelligent error handling with AI analysis
  - Performance optimization with AI profiling
  - AI-generated documentation
  - AI-generated test cases
  - Memory optimization
  - Edge case handling

Pro tip: Use Cmd/Ctrl + K to:
- Analyze performance
- Generate test cases
- Improve type safety
- Add edge cases`,
      example: `// Generated by Cursor AI
// Use Cmd/Ctrl + K for AI assistance
// Use Cmd/Ctrl + L for inline suggestions

/**
 * Utility function powered by Cursor AI
 * @uses Cursor AI type inference
 * @uses Cursor AI performance optimization
 * @uses Cursor AI error analysis
 */
export const smartDeepEqual = <T extends Record<string, any>>(
  a: T,
  b: T
): boolean => {
  // Input validation
  if (!isValidObject(a) || !isValidObject(b)) {
    throw new Error('Invalid input: both arguments must be objects');
  }

  // Performance optimization for identical references
  if (a === b) return true;

  // Get keys once for performance
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);

  // Quick length comparison
  if (keysA.length !== keysB.length) return false;

  // Deep comparison
  return keysA.every(key => {
    const valA = a[key];
    const valB = b[key];

    if (isValidObject(valA) && isValidObject(valB)) {
      return smartDeepEqual(valA, valB);
    }

    return valA === valB;
  });
};

// Helper function for type checking
const isValidObject = (value: unknown): value is Record<string, any> => {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
};

// Unit tests
describe('smartDeepEqual', () => {
  it('should compare objects deeply', () => {
    const obj1 = { a: { b: 1 } };
    const obj2 = { a: { b: 1 } };
    expect(smartDeepEqual(obj1, obj2)).toBe(true);
  });

  it('should handle invalid inputs', () => {
    expect(() => smartDeepEqual(null as any, {}))
      .toThrow('Invalid input');
  });
});`,
    },
  ];

  const categories = Array.from(new Set(templates.map((t) => t.category)));

  const filteredTemplates = templates.filter(
    (t) => t.category === activeCategory
  );

  return (
    <div className="w-full max-w-4xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">Cursor AI Templates</h1>

      <div className="flex gap-4 mb-6">
        {categories.map((category) => (
          <button
            key={category}
            onClick={() => setActiveCategory(category)}
            className={`px-4 py-2 rounded ${
              activeCategory === category
                ? "bg-blue-500 text-white"
                : "bg-gray-200"
            }`}
          >
            {category}
          </button>
        ))}
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="space-y-4">
          {filteredTemplates.map((template, index) => (
            <motion.div
              key={template.title}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.1 }}
              className={`p-4 rounded cursor-pointer ${
                activeTemplate === index
                  ? "bg-blue-100 border-blue-500"
                  : "bg-gray-100"
              }`}
              onClick={() => setActiveTemplate(index)}
            >
              <h3 className="font-bold">{template.title}</h3>
              <p className="text-sm text-gray-600">{template.description}</p>
            </motion.div>
          ))}
        </div>

        <div className="space-y-4">
          <div className="bg-gray-100 p-4 rounded">
            <h3 className="font-bold mb-2">Prompt</h3>
            <CodeBlock
              code={filteredTemplates[activeTemplate]?.prompt || ""}
              language="typescript"
            />
          </div>

          <div className="bg-gray-100 p-4 rounded">
            <h3 className="font-bold mb-2">Example</h3>
            <CodeBlock
              code={filteredTemplates[activeTemplate]?.example || ""}
              language="typescript"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default CommonTemplates;
